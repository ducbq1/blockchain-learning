Solidity là ngôn ngữ lập trình hướng contract, được sử dụng để viết smart contract trong hệ sinh thái Ethereum. Các tài liệu chính về lập trình bằng solidity có thể tìm thấy tại https://docs.soliditylang.org/en/v0.8.9/

Lập trình Blockchain với Solidity

1. Kiểu dữ liệu
- bool
- int/uint (int8 - int256 / uint8 - uint256) (step by 8 bit)
- address: 20 bytes
- byte 
- fixed/ufixed: not support 
- enum 
- function type 
- struct 
- mapping: tương tự hashtable. Cấu trúc mapping(_key => _value). Với _key là bất kỳ kiểu gì ngoại trừ mapping, dynamic-sized, array, contract, enum, struct.
- array:
+ Fixed-sized array: bytesI (với 0 < I <= 32): alias for bytes[I], <type>[]
+ Dynamic-sized array: string, bytes, <type>[]

2. Contract 
Contract tượng tự class trong OOP với các thuộc tính (state variables) và phương thức (functions). Các khái niệm abstract contract (contract với ít nhất một phương thức chưa thực thi), interface (chỉ gồm chữ ký thao tác).
Contract trong solidity cho phép đa kế thừa. Việc này dễ đến nhiều vẫn đề, trong đó có Diamond Problem. Solidity sử dụng thuật toán C3 Linearzation tương tự python để xử lý đa kế thừa. Do vậy thứ tự khai báo kế thừa sau từ khóa is là rât quan trọng.

3. Phương thức 
function <function name> (<parameter type>) [internal | external | public | private]
[pure | constant | view | payable]
{
    returns (<return types>)
}

internal: chỉ có thể truy cập từ các phương thức bên trong contract hoặc từ contract con

external: là một phần của giao diện contract, do đó có thể truy cập từ contract khác. Bản thân contract chứa phương thức cũng có thể gọi nó bằng cách sử dụng từ khóa this

public: là một phần của giao diện contract, có thể gọi từ trong contract mà không cần từ khóa this hoặc từ contract khác

private: chỉ có thể truy cập từ các phương thức trong contract

public vs external: phương thức public cần sao chép tham số vào memory trước khi thực thi (để có thể gọi từ cả trong và ngoài contract), trong khi đó phương thức external có thể đọc trực tiếp từ vùng dữ liệu calldata. Đối với các kiểu dữ liệu phức tạp (array/struct), việc sao chép và cấp phát bộ nhớ là tốn kém hơn so với đọc trực tiếp từ calldata (tốn gas hơn)

private vs internal: phương thức private chỉ có thể truy cập từ trong chính contract của nó, trong khi phương thức internal có thể được gọi từ cả contract con của nó

call vs delegatecall: call sử dụng context (storage) của contract được gọi, trong khi đó delegatecall sử dụng context của contract gọi lệnh delegatecall

Modifier được sử dụng để kiểm soát ngữ cảnh của phương thức.
- pure: không truy cập / thay đổi các thuộc tính của contract
- view: không thay đổi thuộc tính của contract
- constant: constant at runtime
- payable: phải có với các phương thức sử dụng msg.value / nếu muốn nhận Ether

Fallback function: mỗi contract có duy nhất một phương thức không có tên gọi là fallback function. Phương thức này không có tham sô tuy nhiên vẫn có thể sử dụng msg.data để lấy dữ liệu truyền theo lời gọi, cũng không có giá trị trả về. Phương thức này chỉ được gọi khi không có bất kì phương thức nào của contract khớp với lời gọi.

Thuộc tính: internal, public, private
Data location: memory / storage / calldata
